---
title: 事件分发源码分析
date: 2021-01-19 20:22:01
categories: Android
tags: 
- Android
- 源码分析
---

首先事件最先传递给当前的Activity，由Activity的`dispatchTouchEvent`来进行事件分发。

Activity的`dispatchTouchEvent`代码如下

```java
/**
  * Called to process touch screen events.  You can override this to
  * intercept all touch screen events before they are dispatched to the
  * window.  Be sure to call this implementation for touch screen events
  * that should be handled normally.
  *
  * @param ev The touch screen event.
  *
  * @return boolean Return true if this event was consumed.
  */
public boolean dispatchTouchEvent(MotionEvent ev) {
  if (ev.getAction() == MotionEvent.ACTION_DOWN) {
    // 空方法 当键盘、触摸、trackball事件被分发到当前Activity时，这个方法被回调
    // 子类重写这个方法可以用于感知用户与设备的交互
    onUserInteraction();
  }
  // 1-1 这里把MotionEvent交由Window去处理，如果结果是true，代表事件被消费了，直接返回true就行
  if (getWindow().superDispatchTouchEvent(ev)) {
    return true;
  }
  // 1-2 如果MotionEvent没有被处理，交回来给Activity的onTouchEvent来处理
  return onTouchEvent(ev);
}
```
在1-1这里，Activity就把MotionEvent交给Window去处理了，我们知道，Window的唯一子类就是`PhoneWindow`，所以接下来的流程我们就跳转到`PhoneWindow`里去看。

<!--more-->

```java
// This is the top-level view of the window, containing the window decor.
private DecorView mDecor;

@Override
public boolean superDispatchTouchEvent(MotionEvent event) {
  // 2-1 PhoneWindow将MotionEvent移交给DecorView去处理
  return mDecor.superDispatchTouchEvent(event);
}
```

2-1: PhoneWindow又将MotionEvent交由`DecorView`去处理

```java
 public boolean superDispatchTouchEvent(MotionEvent event) {
   // 3-1 DecorView其实是一个FrameLayout super.dispatchTouchEvent调用的是ViewGroup的方法
   return super.dispatchTouchEvent(event);
 }
```

我们知道`Window`、`DecorView`、`contentView`的层级如下图所示

![Window、DecorView、ContentView层级关系](https://bright-blog-1301150773.cos.ap-guangzhou.myqcloud.com/Window%E3%80%81DecorView%E3%80%81ContentView%E5%B1%82%E7%BA%A7%E5%85%B3%E7%B3%BB.png)

DecorView的子控件`R.layout.screen_simple`、`R.id.content`这些都是ViewGroup。自己编写的`R.layout.main_activity`可以是View，也可以是ViewGroup。所以DecorView内部的控件就是ViewGroup一层一层嵌套，直到最后的View。所以我们继续从ViewGroup的`dispatchTouchEvent`往下看，这里也是ViewGroup分发事件的主要过程。

`dispatchTouchEvent`方法有点长，我们拆解一下来看看，首先，我们手机在屏幕上点击或滑动，都是一系列的事件，每一次事件都是从`MotionEvent.ACTION_DOWN`开始的

- 第一部分，就是对事件系列中的最开始`MotionEvent.ACTION_DOWN`的处理

  ```java
  public boolean dispatchTouchEvent(MotionEvent ev) {
    
      boolean handled = false;
      if (onFilterTouchEventForSecurity(ev)) {
          // ------------ 第一部分 针对事件初始进行前置准备处理 ------------
          final int action = ev.getAction();
          final int actionMasked = action & MotionEvent.ACTION_MASK;
          // 最初的DOWN事件处理
          if (actionMasked == MotionEvent.ACTION_DOWN) {
              // Throw away all previous state when starting a new touch gesture.
              // The framework may have dropped the up or cancel event for the previous gesture
              // due to an app switch, ANR, or some other state change.
            	// 4-1 向mFirstTouchTarget指向的子元素分发cancel事件，然后将mFirstTouchTarget清除置为null
              cancelAndClearTouchTargets(ev);
            	// 4-2 重置所有触摸状态，为下一个事件周期做准备
              resetTouchState();
          }
          // ------------ 第一部分 结束 ------------
        
  				// ...
      }
  
      if (!handled && mInputEventConsistencyVerifier != null) {
          mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);
      }
      return handled;
  }
  ```

  4-1中`cancelAndClearTouchTargets`，作用就是清除之前的事件，为新一轮的事件分发做准备

  ```java
  private void cancelAndClearTouchTargets(MotionEvent event) {
      if (mFirstTouchTarget != null) {
          boolean syntheticEvent = false;
          if (event == null) {
              final long now = SystemClock.uptimeMillis();
            	// 构建一个ACTION_CANCEL的事件
              event = MotionEvent.obtain(now, now,
                      MotionEvent.ACTION_CANCEL, 0.0f, 0.0f, 0);
              event.setSource(InputDevice.SOURCE_TOUCHSCREEN);
              syntheticEvent = true;
          }
  
          for (TouchTarget target = mFirstTouchTarget; target != null; target = target.next) {
              resetCancelNextUpFlag(target.child);
            	// 向mFirstTouchTarget指向的子元素分发cancel事件
              dispatchTransformedTouchEvent(event, true, target.child, target.pointerIdBits);
          }
        	// 清除mFirstTouchTarget中的节点，置为null
          clearTouchTargets();
  
          if (syntheticEvent) {
              event.recycle();
          }
      }
  }
  ```

  4-2中的`resetTouchState`就是 重置所有触摸状态，为下一个事件周期做准备

  ```java
  private void resetTouchState() {
      clearTouchTargets();
      resetCancelNextUpFlag(this);
      mGroupFlags &= ~FLAG_DISALLOW_INTERCEPT;
      mNestedScrollAxes = SCROLL_AXIS_NONE;
  }
  ```

- 第二部分 处理当前ViewGroup是否要拦截事件

  ```java
  // ------------ 第二部分 判断当前ViewGroup是否需要拦截事件 ------------      
      // Check for interception.
      final boolean intercepted;
      if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {
          final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;
          if (!disallowIntercept) {
              intercepted = onInterceptTouchEvent(ev);
              ev.setAction(action); // restore action in case it was changed
          } else {
              intercepted = false;
          }
      } else {
          // There are no touch targets and this action is not an initial down
          // so this view group continues to intercept touches.
          intercepted = true;
      }
  // ------------ 第二部分 结束 ------------
  ```

  定义一个`boolean`类型的标志量`intercepted`，这个是用于记录该ViewGroup是否要拦截事件，可以看到 ViewGroup会在`actionMasked == MotionEvent.ACTION_DOWN`和`mFirstTouchTarget != null`这个条件下来进行是否需要拦截事件的判断，`mFirstTouchTarget`指向的是该ViewGroup的能处理事件成功的子View。那么如果ViewGroup拦截了事件，`mFirstTouchTarget`就是为null的，那么接下来的MOVE和UP事件则继续保持拦截状态，不会进入判断条件。

  

  然后在具体是否拦截的判断条件是是否设置了`FLAG_DISALLOW_INTERCEPT`标记位，如果设置了，该ViewGroup是不会拦截事件的，这个标志位一般是子View通过`getParent().requestDisallowInterceptTouchEvent(true)`来设置，子View请求父控件不要拦截事件。如果没有设置，再通过该ViewGroup自身的`onInterceptTouchEvent(ev)`方法返回值来判断是否需要拦截，这个方法通常就是继承类来覆写该方法来控制是否拦截事件。

- 第三部分 遍历子View，判断子View是否需要拦截或处理事件

  ```java
  // ------------ 第三部分 遍历子View，判断子View是否需要拦截或处理事件 ------------      
  // Check for cancelation.
  final boolean canceled = resetCancelNextUpFlag(this)
          || actionMasked == MotionEvent.ACTION_CANCEL;
  
  // Update list of touch targets for pointer down, if needed.
  final boolean split = (mGroupFlags & FLAG_SPLIT_MOTION_EVENTS) != 0;
  TouchTarget newTouchTarget = null;
  boolean alreadyDispatchedToNewTouchTarget = false;
  if (!canceled && !intercepted) {
      if (actionMasked == MotionEvent.ACTION_DOWN
              || (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN)
              || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
          final int actionIndex = ev.getActionIndex(); // always 0 for down
          final int idBitsToAssign = split ? 1 << ev.getPointerId(actionIndex)
                  : TouchTarget.ALL_POINTER_IDS;
  
          // Clean up earlier touch targets for this pointer id in case they
          // have become out of sync.
          removePointersFromTouchTargets(idBitsToAssign);
  
          final int childrenCount = mChildrenCount;
          if (newTouchTarget == null && childrenCount != 0) {
              final float x = ev.getX(actionIndex);
              final float y = ev.getY(actionIndex);
              // Find a child that can receive the event.
              // Scan children from front to back.
              final ArrayList<View> preorderedList = buildTouchDispatchChildList();
              final boolean customOrder = preorderedList == null
                      && isChildrenDrawingOrderEnabled();
              final View[] children = mChildren;
            	// 5-1 从最前面往里面遍历子View
              for (int i = childrenCount - 1; i >= 0; i--) {
                  final int childIndex = getAndVerifyPreorderedIndex(
                          childrenCount, i, customOrder);
                  final View child = getAndVerifyPreorderedView(
                          preorderedList, children, childIndex);
  								// 5-2 判断子View是否能够接受到事件
                  if (!canViewReceivePointerEvents(child)
                          || !isTransformedTouchPointInView(x, y, child, null)) {
                      ev.setTargetAccessibilityFocus(false);
                      continue;
                  }
  
                  newTouchTarget = getTouchTarget(child);
                  if (newTouchTarget != null) {
                      // Child is already receiving touch within its bounds.
                      // Give it the new pointer in addition to the ones it is handling.
                      newTouchTarget.pointerIdBits |= idBitsToAssign;
                      break;
                  }
  
                  resetCancelNextUpFlag(child);
                	// 5-3 将事件交由子View去dispatchTouchEvent，看子View是否处理事件
                  if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                      // Child wants to receive touch within its bounds.
                      mLastTouchDownTime = ev.getDownTime();
                      if (preorderedList != null) {
                          // childIndex points into presorted list, find original index
                          for (int j = 0; j < childrenCount; j++) {
                              if (children[childIndex] == mChildren[j]) {
                                  mLastTouchDownIndex = j;
                                  break;
                              }
                          }
                      } else {
                          mLastTouchDownIndex = childIndex;
                      }
                      mLastTouchDownX = ev.getX();
                      mLastTouchDownY = ev.getY();
                    	// 5-4 将处理事件的View添加到mFirstTouchTarget(链表)最前端
                      newTouchTarget = addTouchTarget(child, idBitsToAssign);
                      alreadyDispatchedToNewTouchTarget = true;
                      break;
                  }
              }
              if (preorderedList != null) preorderedList.clear();
          }
  
          if (newTouchTarget == null && mFirstTouchTarget != null) {
              // Did not find a child to receive the event.
              // Assign the pointer to the least recently added target.
              newTouchTarget = mFirstTouchTarget;
              while (newTouchTarget.next != null) {
                  newTouchTarget = newTouchTarget.next;
              }
              newTouchTarget.pointerIdBits |= idBitsToAssign;
          }
      }
  }
  // ------------ 第三部分 结束 ------------      
  ```

  在5-1处，从外层往里层依次遍历子View，然后在5-2处判断子View是否能够接受处理事件，判断条件是`canViewReceivePointerEvents(child)`和`isTransformedTouchPointInView(x, y, child, null)`，具体代码如下：

  ```java
  private static boolean canViewReceivePointerEvents(@NonNull View child) {
    	// 是否可见，是否在播放动画
      return (child.mViewFlags & VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null;
  }
  ```

  ```java
  protected boolean isTransformedTouchPointInView(float x, float y, View child,
          PointF outLocalPoint) {
    	// 判断点击事件是否在子View的区域内
      final float[] point = getTempPoint();
      point[0] = x;
      point[1] = y;
      transformPointToViewLocal(point, child);
      final boolean isInView = child.pointInView(point[0], point[1]);
      if (isInView && outLocalPoint != null) {
          outLocalPoint.set(point[0], point[1]);
      }
      return isInView;
  }
  ```

  就是说子View不能接收点击事件或者点击事件不在该子View的区域内，那么事件也就不会分发到这个子View去，跳过这个子View继续遍历。

  如果子View满足这两个条件，那么事件就会传递给它来处理，进入5-3处的 `dispatchTransformedTouchEvent`来看，撇开那些判断条件，最终的处理结果都依赖下面的代码，

  ```java
  if (child == null) {
      handled = super.dispatchTouchEvent(event);
  } else {
      handled = child.dispatchTouchEvent(event);
  }
  ```

  这里child传入的不为null，所以这里会执行子View的`dispatchTouchEvent`，如果`dispatchTouchEvent`返回的是true，那就暂时不考虑子View内部的分发逻辑，这里会走进if判断条件，执行到5-4处。

  ```java
  private TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) {
      final TouchTarget target = TouchTarget.obtain(child, pointerIdBits);
      target.next = mFirstTouchTarget;
      mFirstTouchTarget = target;
      return target;
  }
  ```

  这里是对`mFirstTouchTarget`进行赋值，然后将`mFirstTouchTarget`当成一个子View是否处理事件的标志。如果是有子View处理事件，将`mFirstTouchTarget`赋值后，然后就跳出遍历子View的循环，如果当前子View的`dispatchTransformedTouchEvent`返回的是false，则继续往下遍历子View。

- 第四部分 根据`mFirstTouchTarget`来分发事件，为null则是将事件交由ViewGroup的onTouchEvent处理

  ```java
  // ------------ 第四部分 根据mFirstTouchTarget来分发事件，为null则是ViewGroup的onTouchEvent处理 ------------ 
  // Dispatch to touch targets.
  if (mFirstTouchTarget == null) {
      // No touch targets so treat this as an ordinary view.
    	// 6-1 如果事件被该ViewGroup拦截了，或者没有子view处理事件
      handled = dispatchTransformedTouchEvent(ev, canceled, null,
              TouchTarget.ALL_POINTER_IDS);
  } else {
      // Dispatch to touch targets, excluding the new touch target if we already
      // dispatched to it.  Cancel touch targets if necessary.
    	// 6-1 遍历mFirstTouchTarget，分发事件
      TouchTarget predecessor = null;
      TouchTarget target = mFirstTouchTarget;
      while (target != null) {
          final TouchTarget next = target.next;
          if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {
              handled = true;
          } else {
              final boolean cancelChild = resetCancelNextUpFlag(target.child)
                      || intercepted;
              if (dispatchTransformedTouchEvent(ev, cancelChild,
                      target.child, target.pointerIdBits)) {
                  handled = true;
              }
              if (cancelChild) {
                  if (predecessor == null) {
                      mFirstTouchTarget = next;
                  } else {
                      predecessor.next = next;
                  }
                  target.recycle();
                  target = next;
                  continue;
              }
          }
          predecessor = target;
          target = next;
      }
  }
  // ------------ 第四部分 结束 ------------ 
  ```

  接着第三部分，如果没有子View没有处理事件(1. 有可能没有子View 2. 子View处理了事件，dispatchTouchEvent返回false)，这个时候`mFirstTouchTarget`是没有赋值的，为null，那么会走到代码6-1处。

  这里跟5-3处调用的是一个方法，但是child参数传递的是null，那么就会执行`super.dispatchTouchEvent(event)`这行代码，会跳转到ViewGroup的父类View的`dispatchTouchEvent`，而View的`dispatchTouchEvent`就会调用`onTouchEvent`，也就是该ViewGroup自己通过`onTouchEvent`方法来处理事件。

到这里，ViewGroup里的事件分发与拦截就分析完毕了，事件要么就交由下层View继续处理，要么就走到自己的`onTouchEvent`方法里处理。如果下层View还是ViewGroup，则逻辑还是跟上面分析的一样，如果是View，那么流程就有点不同了。

 - View的dispatchTouchEvent

   ```java
   public boolean dispatchTouchEvent(MotionEvent event) {
       // ...
   
       boolean result = false;
   
       // ...
   
       if (onFilterTouchEventForSecurity(event)) {
           if ((mViewFlags & ENABLED_MASK) == ENABLED && handleScrollBarDragging(event)) {
               result = true;
           }
           //noinspection SimplifiableIfStatement
           ListenerInfo li = mListenerInfo;
           // 7-1 判断是否设置了OnTouchListener，设置了就交由listener处理
           if (li != null && li.mOnTouchListener != null
                   && (mViewFlags & ENABLED_MASK) == ENABLED
                   && li.mOnTouchListener.onTouch(this, event)) {
               result = true;
           }
   
           // 7-2 没设置OnTouchListener，交由View的onTouchEvent方法来处理事件
           if (!result && onTouchEvent(event)) {
               result = true;
           }
       }
   
       // ...
   
       return result;
   }
   ```

   View因为没有下层的子View了，所以dispatchTouchEvent也比较简单，从代码7-1和7-2可以很清晰看到View分发事件的逻辑，首先看是否设置了OnTouchEventListener，如果没有设置listener，再去看该View的onTouchEvent方法。OnTouchEventListener的优先级是高于onTouchEvent方法的，这样就可以暴露OnTouchEventListener，方便于View在外面处理点击事件了。

- View的onTouchEvent

  ```java
  public boolean onTouchEvent(MotionEvent event) {
      final float x = event.getX();
      final float y = event.getY();
      final int viewFlags = mViewFlags;
      final int action = event.getAction();
  
      // ------------ 第一部分 View处于不可用状态下点击事件的处理  ------------
      final boolean clickable = ((viewFlags & CLICKABLE) == CLICKABLE
              || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE)
              || (viewFlags & CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;
  
      if ((viewFlags & ENABLED_MASK) == DISABLED) {
          if (action == MotionEvent.ACTION_UP && (mPrivateFlags & PFLAG_PRESSED) != 0) {
              setPressed(false);
          }
          mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
          // A disabled view that is clickable still consumes the touch
          // events, it just doesn't respond to them.
        	// 不可用状态下，view也会消耗事件，只是不响应它们
          return clickable;
      }
      // ------------ 第一部分 结束  ------------
      
      // ------------ 第二部分 有TouchDelegate则交由TouchDelegate处理事件  ------------
      if (mTouchDelegate != null) {
          if (mTouchDelegate.onTouchEvent(event)) {
              return true;
          }
      }
      // ------------ 第二部分 结束  ------------
    
      // ------------ 第三部分 点击事件的具体处理  ------------
      if (clickable || (viewFlags & TOOLTIP) == TOOLTIP) {
          switch (action) {
              case MotionEvent.ACTION_UP:
                  mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
                  if ((viewFlags & TOOLTIP) == TOOLTIP) {
                      handleTooltipUp();
                  }
                  if (!clickable) {
                      removeTapCallback();
                      removeLongPressCallback();
                      mInContextButtonPress = false;
                      mHasPerformedLongPress = false;
                      mIgnoreNextUpEvent = false;
                      break;
                  }
                  boolean prepressed = (mPrivateFlags & PFLAG_PREPRESSED) != 0;
                  if ((mPrivateFlags & PFLAG_PRESSED) != 0 || prepressed) {
                      // take focus if we don't have it already and we should in
                      // touch mode.
                      boolean focusTaken = false;
                      if (isFocusable() && isFocusableInTouchMode() && !isFocused()) {
                          focusTaken = requestFocus();
                      }
  
                      if (prepressed) {
                          // The button is being released before we actually
                          // showed it as pressed.  Make it show the pressed
                          // state now (before scheduling the click) to ensure
                          // the user sees it.
                          setPressed(true, x, y);
                      }
  
                      if (!mHasPerformedLongPress && !mIgnoreNextUpEvent) {
                          // This is a tap, so remove the longpress check
                          removeLongPressCallback();
  
                          // Only perform take click actions if we were in the pressed state
                          if (!focusTaken) {
                              // Use a Runnable and post this rather than calling
                              // performClick directly. This lets other visual state
                              // of the view update before click actions start.
                            	// 8-1 针对点击事件处理 通过Runnable调用performClickInternal() ，最终调用performClick()方法
                              if (mPerformClick == null) {
                                  mPerformClick = new PerformClick();
                              }
                              if (!post(mPerformClick)) {
                                  performClickInternal();
                              }
                          }
                      }
  
                      if (mUnsetPressedState == null) {
                          mUnsetPressedState = new UnsetPressedState();
                      }
  
                      if (prepressed) {
                          postDelayed(mUnsetPressedState,
                                  ViewConfiguration.getPressedStateDuration());
                      } else if (!post(mUnsetPressedState)) {
                          // If the post failed, unpress right now
                          mUnsetPressedState.run();
                      }
  
                      removeTapCallback();
                  }
                  mIgnoreNextUpEvent = false;
                  break;
  
              case MotionEvent.ACTION_DOWN:
                  if (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) {
                      mPrivateFlags3 |= PFLAG3_FINGER_DOWN;
                  }
                  mHasPerformedLongPress = false;
  
                  if (!clickable) {
                    	// 8-2 针对长按事件处理 
                      checkForLongClick(0, x, y);
                      break;
                  }
  
                  if (performButtonActionOnTouchDown(event)) {
                      break;
                  }
  
                  // Walk up the hierarchy to determine if we're inside a scrolling container.
                  boolean isInScrollingContainer = isInScrollingContainer();
  
                  // For views inside a scrolling container, delay the pressed feedback for
                  // a short period in case this is a scroll.
                  if (isInScrollingContainer) {
                      mPrivateFlags |= PFLAG_PREPRESSED;
                      if (mPendingCheckForTap == null) {
                          mPendingCheckForTap = new CheckForTap();
                      }
                      mPendingCheckForTap.x = event.getX();
                      mPendingCheckForTap.y = event.getY();
                      postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                  } else {
                      // Not inside a scrolling container, so show the feedback right away
                      setPressed(true, x, y);
                      checkForLongClick(0, x, y);
                  }
                  break;
  
              case MotionEvent.ACTION_CANCEL:
                  if (clickable) {
                      setPressed(false);
                  }
                  removeTapCallback();
                  removeLongPressCallback();
                  mInContextButtonPress = false;
                  mHasPerformedLongPress = false;
                  mIgnoreNextUpEvent = false;
                  mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
                  break;
  
              case MotionEvent.ACTION_MOVE:
                  if (clickable) {
                      drawableHotspotChanged(x, y);
                  }
  
                  // Be lenient about moving outside of buttons
                  if (!pointInView(x, y, mTouchSlop)) {
                      // Outside button
                      // Remove any future long press/tap checks
                      removeTapCallback();
                      removeLongPressCallback();
                      if ((mPrivateFlags & PFLAG_PRESSED) != 0) {
                          setPressed(false);
                      }
                      mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
                  }
                  break;
          }
          return true;
      }
      // ------------ 第三部分 结束  ------------
      return false;
  }
  ```

  从以上代码我们可以看到，View的OnTouchEvent方法主要分为三个部分，首先对不可用的状态进行处理，虽然处于不可用状态，但是还是会消费点击事件，只是没什么响应而已。第二部分则是对设置了`TouchDelegate`的处理。重点在第三部分，这里就是我们非常熟悉的针对MotionEvent不同action类型(DOWN、MOVE、CANCEL、UP)的处理。

  其中8-1代码处就是针对点击事件处理，通过post Runnable调用`performClickInternal() `，确保view的状态在点击前进行一遍更新。最终调用`performClick()`方法

  ```java
  public boolean performClick() {
      // We still need to call this method to handle the cases where performClick() was called
      // externally, instead of through performClickInternal()
      notifyAutofillManagerOnClick();
  
      final boolean result;
      final ListenerInfo li = mListenerInfo;
    	// 在这里回调出去，具体处理View的onClick事件
      if (li != null && li.mOnClickListener != null) {
          playSoundEffect(SoundEffectConstants.CLICK);
          li.mOnClickListener.onClick(this);
          result = true;
      } else {
          result = false;
      }
  
      sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);
  
      notifyEnterOrExitForAutoFillIfNeeded(true);
  
      return result;
  }
  ```

  8-2处代码是在MotionEvent.ACTION_DOWN里去判断view要不要响应长按事件，具体实现跟点击事件类似，最终响应到View的`OnLongClickListener`去处理长按事件，这里具体就不再展开了。

总结

1. `onInterceptTouchEvent`方法代表是否需要拦截事件，`onTouch`和`onTouchEvent`方法的返回值代表是否消费事件
2. 事件从Activity一层一层往底部View进行分发，过程中，各个ViewGroup都可以选择拦截事件，拦截后则交由该ViewGroup的`onTouchEvent`处理，不再继续分发
3. 都不拦截的情况下，会分发到子View，如果view都不选择消费事件，事件会通过`onTouchEvent`一层一层往上冒泡，直到回到Activity的`onTouchEvent`，有一层选择消费事件，则不再往上传递
4. 子View可以通过`getParent().requestDisallowInterceptTouchEvent`来申请父控件不要拦截事件
5. 如果View没有消费`ACTION_DOWN`事件，之后的`ACTION_MOVE\ACTION_UP`事件不会再接收
6. 当View设置了可点击、可常按，那么就算该View不可用，也会消费事件
7. `onTouch`优先级比`onTouchEvent`高，只有`onTouch`不执行的情况下，才会执行`onTouchEvent`

事件分发流程图如下：

![Touch事件分发流程](https://bright-blog-1301150773.cos.ap-guangzhou.myqcloud.com/Touch%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%B5%81%E7%A8%8B.png)



